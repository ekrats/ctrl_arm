/** ###################################################################
**     THIS BEAN MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename  : PC_M1.C
**     Project   : DSPC51
**     Processor : 56F8037
**     Beantype  : PC_Master
**     Version   : Bean 01.032, Driver 01.13, CPU db: 2.87.237
**     Compiler  : Metrowerks DSP C Compiler
**     Date/Time : 2011-2-23, ÏÂÎç 01:51
**     Abstract  :
**          The PC master software application is a software tool initially created
**          for developers of Motor Control applications but it may be extended to any
**          application development. This tool allows control of an application remotely
**          from a user-friendly graphical environment running on a PC.
**     Comment   :
**         8030
**     Settings  :
**          AsynchroSerial                       : Inhr7
**
**          Initialization:
**              Recorder buffer length           : 512
**              Command buffer length            : 4
**              Data buffer size                 : 128
**              Recorder timebase                : 32816
**              Board firmware major number      : 5
**              Board firmware minor number      : 0
**              Device identification string     : PC Master communication !
**     Contents  :
**         pcmasterdrvInit     - Word16 PC_M1_pcmasterdrvInit(sPCMasterComm *p_sPCMasterComm);
**         pcmasterdrvRecorder - void pcmaster_record(void);
**
**     (c) Freescale Semiconductor
**     2004 All Rights Reserved
**
**     (c) Copyright UNIS, spol. s r.o. 1997-2006
**     UNIS, spol. s r.o.
**     Jundrovska 33
**     624 00 Brno
**     Czech Republic
**     http      : www.processorexpert.com
**     mail      : info@processorexpert.com
** ###################################################################*/
#include "pcmaster_conf.h"
#include "pcmaster.h"

/* MODULE PC_M1. */

/* set configuration of PC Master */
/*-----------------
  standard commands
  -----------------*/
#define PCMDRV_CMD_READMEM          0x01 /* read block of memory */
#define PCMDRV_CMD_WRITEMEM         0x02 /* write block of memory */
#define PCMDRV_CMD_WRITEMEMMASK     0x03 /* write block of memory with mask */
#define PCMDRV_CMD_READMEMEX        0x04 /* v3+ */
#define PCMDRV_CMD_WRITEMEMEX       0x05 /* v3+ */
#define PCMDRV_CMD_WRITEMEMMASKEX   0x06 /* v3+ */
#define PCMDRV_CMD_SETUPSCOPE       0x08 /* setup scope */
#define PCMDRV_CMD_SETUPREC         0x09 /* setup recorder */
#define PCMDRV_CMD_SETUPSCOPEEX     0x0A /* v3+ */
#define PCMDRV_CMD_SETUPRECEX       0x0B /* v3+ */
#define PCMDRV_CMD_CALLAPPCMD       0x10 /* call user application command */

  /*-----------------
     special commands
    -----------------*/
    /* no data part */
#define PCMDRV_CMD_GETINFO          0xC0 /* get system information */
#define PCMDRV_CMD_STARTREC         0xC1 /* start recorder */
#define PCMDRV_CMD_STOPREC          0xC2 /* stop recorder */
#define PCMDRV_CMD_GETRECSTS        0xC3 /* get recorder status */
#define PCMDRV_CMD_GETRECBUFF       0xC4 /* get recorder buffer information */
#define PCMDRV_CMD_READSCOPE        0xC5 /* read scope variables */
#define PCMDRV_CMD_GETAPPCMDSTS     0xC6 /* get user application command status */
#define PCMDRV_CMD_GETINFOBRIEF     0xC8 /* v2+ get brief system information */
#define PCMDRV_CMD_GETRECBUFFEX     0xC9 /* v3+ */
/* 2 bytes data part */
#define PCMDRV_CMD_READVAR8         0xD0 /* read 8-bit variable from 16-bit address */
#define PCMDRV_CMD_READVAR16        0xD1 /* read 16-bit variable from 16-bit address */
#define PCMDRV_CMD_READVAR32        0xD2 /* read 32-bit variable from 16-bit address */
/* 4 bytes data part */
#define PCMDRV_CMD_READVAR8EX       0xE0 /* read 8-bit variable from 32-bit address */
#define PCMDRV_CMD_READVAR16EX      0xE1 /* read 16-bit variable from 32-bit address */
#define PCMDRV_CMD_READVAR32EX      0xE2 /* read 32-bit variable from 32-bit address */

/*-------------
  status bytes
  -------------*/
#define PCMDRV_STC_OK               0x00 /* operation succesful */
#define PCMDRV_STC_RECRUN           0x01 /* recorder running */
#define PCMDRV_STC_RECDONE          0x02 /* recorder finished */
  /* error codes */
#define PCMDRV_STC_INVCMD           0x81 /* invalid command */
#define PCMDRV_STC_CMDSERR          0x82 /* checksum error */
#define PCMDRV_STC_CMDBUFFOVF       0x83 /* command too long */
#define PCMDRV_STC_RSPBUFFOVF       0x84 /* response would be too long */
#define PCMDRV_STC_INVBUFF          0x85 /* invalid buffer length specified */
#define PCMDRV_STC_INVSIZE          0x86 /* invalid size */
#define PCMDRV_STC_SERVBUSY         0x87 /* service is busy */
#define PCMDRV_STC_NOTINIT          0x88 /* scope/recorder not configured */
#define PCMDRV_STC_UNKNOWN          0xFF /* reserved */

/* recorder trigger modes */
#define PCMDRV_REC_TRIGOFF             0 /* manual mode (trigger disabled) */
#define PCMDRV_REC_TRIGRIS             1 /* rising edge */
#define PCMDRV_REC_TRIGFAL             2 /* falling edge */

#define PCMDRV_IDT_STRING_LEN         25 /* length of identification string */

/* get info command parameters */
#define PCMDRV_PROT_VER                3 /* PC Master protocol version */
#define PCMDRV_DATABUSWDT              1 /* data bus width */
#define PCMDRV_CFG_FLAFGS         0x000C /* little endian data format + no fast writes */

/* PC Master initialization */
#define PC_MASTER_IDT_STRING          "PC Master communication !" /* Identification string of the device */

/*------------------------------------------------------------------------------------------------------*/
/*                    structure with SCI communication settings                                         */
/*------------------------------------------------------------------------------------------------------*/
typedef struct 
{
    uint8_t     *p_dataBuff;         /* pointer to input/output communication buffer */
    uint8_t     dataBuffSize;        /* size of input/output communication buffer */
    uint8_t     *p_recBuff;          /* pointer to recorder buffer */
    uint16_t    recSize;             /* recorder buffer size */
    uint8_t     *p_recorder;         /* structure with recorder settings and temporary variables */
    uint8_t     *p_scope;            /* structure with scope settings */
    uint16_t    timeBase;            /* period of Recorder Routine launch */
    uint8_t     *p_appCmdBuff;       /* pointer to application command buffer */
    uint8_t     appCmdSize;          /* application command buffer size */
    uint8_t     globVerMajor;        /* board firmware version major number */
    uint8_t     globVerMinor;        /* board firmware version minor number */
    uint8_t     idtString[PCMDRV_IDT_STRING_LEN]; /* device identification string */
} sPCMasterComm;

/*------------------------------------------------------------------------------------------------------*/
/* recorder settings structure (recorder settings and temporary variables are stored in this structure) */
/*------------------------------------------------------------------------------------------------------*/
typedef struct {
    uint16_t           cmd;
    uint16_t           cmdLen;
    uint16_t           trgMode;     /* 0x00 - manual, 0x01 - rising edge, 0x02 - falling edge   */
    uint16_t           totalSmps;   /* number of samples required                               */
    uint16_t           postTrigger; /* samples after trigger                                    */
    uint16_t           timeDiv;     /* time div                                                 */
    uint32_t           trgVarAddr[1]; /* address of trigger variable                              */
    uint16_t           trgVarSize;  /* size of variable (bytes)                                 */
    uint16_t           trgVarSigned; /* 0x00 - unsigned, 0x01 - signed                           */

    union 
    {                         /* union is used to access various types of treshold        */
        uint8_t          uch;         /* trgVarSize == 1                                          */
        int8_t           ch;          /* trgVarSize == 1                                          */
        uint16_t         uw;          /* trgVarSize == 2                                          */
        uint32_t         ud;          /* trgVarSize == 2                                          */
        int16_t          sw;          /* trgVarSize == 4                                          */
        long             sd;          /* trgVarSize == 4                                          */
    } trgThreshold;                /* trigger threshold                                        */

    uint16_t           varCnt;      /* number of variables                                      */

    struct
    {
        uint16_t         varSize;     /* size of variable                                         */
        uint32_t         varAddr[1];  /* address of variable                                      */
    } varDef[8];

    uint16_t           recPos;      /* position in recorder buffer - position of the next samples (incremented with RecSetLen) */
    uint16_t           recSetLen;   /* length of required set of variables (in words) */
    uint16_t           recToEnd;    /* position to end of buff (the variable is decremented after trigger & recorder stops at 0) */
    uint16_t           recTime;     /* time div of Recorder */

    /* recorder last value (last value the triggering variable is stored after launch of Recorder routine)  */
    union 
    {
        uint8_t          uch;
        int8_t           ch;
        uint16_t         uw;
        uint32_t         ud;
        int16_t          sw;
        long             sd;
    } recLastVal;                  /* last value of synchronizing variable */
} pcmdrv_sRecorder;

/*------------------------------------------------------------------------------------------------------*/
/*                scope settings buffer (scope settings are stored in this structure)                   */
/*------------------------------------------------------------------------------------------------------*/
typedef struct 
{
    unsigned char varCnt;
    struct 
    {
        uint8_t varSize;               /* size of scope variable */
        uint8_t addrByte[4];           /* address of scope variable */
    } varDef[8];                   /* maximum number of variables is 8 */
} pcmdrv_sScope;

/*******************************************************
* Bit Manipulation Operations
*******************************************************/

/* void bitSet(Mask, Addr); */
#define bitSet(Mask, Addr)             ((Addr) |= (Mask)) //((void *) 0) //asm(bfset    Mask,Addr)

/* void bitClear(Mask, Addr); */
#define bitClear(Mask, Addr)            ((Addr) &= ~(Mask))//((void *) 0)//asm(bfclr    Mask,Addr)

/* void bitChange(Mask, Addr); */
#define bitChange(Mask, Addr)           ((void *) 0)//asm(bfchg    Mask,Addr)

/* void bitTestHigh(Mask, Addr); */
#define bitTestHigh(Mask, Addr)         ((void *) 0)//asm(bftsth   Mask,Addr)

/* void bitTestLow(Mask, Addr); */
#define bitTestLow(Mask, Addr)          ((void *) 0)//asm(bftstl   Mask,Addr)


/* void bitWordSet(Mask, Addr); */
#define bitWordSet(Mask, Addr)   (*Addr = Mask | *Addr)

/* void bitWordClear(Mask, Addr); */
#define bitWordClear(Mask, Addr) (*Addr = ~Mask & *Addr)

#define pcmasterdrvInit(sPCMasterComm) PC_M1_pcmasterdrvInit(sPCMasterComm)

int16_t PC_M1_pcmasterdrvInit(sPCMasterComm *p_sPCMasterComm);
#include "pcmaster.h"
#include "string.h"

/*--------------------------------------------------
        define which commands will be compiled
  --------------------------------------------------*/
#define PCMDRV_INCLUDE_CMD_SCOPE       /* read scope, setup scope */
#define PCMDRV_INCLUDE_CMD_RECORDER    /* setup recorder, get recorder buffer info,*/
  /* start recorder, stop recorder get recorder status */
#define PCMDRV_INCLUDE_CMD_APPCMD      /* call app comd, app comd get status */
#undef PCMDRV_INCLUDE_CMD_GETINFOBRIEF /* enable getinfobrief command   */
                                       /* (default = getinfo command)   */

/* call user application command status */
/* no application command called (board after reset) */
#define PCMDRV_APPCMD_NOCMD         0xFF
/* application command not finished */
#define PCMDRV_APPCMD_RUNNING       0xFE

/* status byte masks (used with 'status' variable) */
/* receiving started, beginning of message already detected ('+') */
#define ST_STARTED                0x0010
/* last received char was '+' */
#define ST_ST_CHAR_REC            0x0020
/* received message is standard command (for length decoding) */
#define ST_STD_CMD                0x0040
/* recorder is running (trigger already detected) */
#define ST_RECRUNNING             0x0100
/* recorder is activated (waiting for trigger) */
#define ST_RECACTIVATED           0x0200
/* read pretrigger samples before waiting for trigger */
#define ST_REC_READ_PRETRIG       0x0400
/* response is being send to PC */
#define ST_SENDING                0x1000
/* last sent char was '+' */
#define ST_ST_SENT                0x2000
/* checksum already added to the message */
#define ST_CS_ADDED               0x4000

#define START         '+'              /* start of message */

/* types of recorder trigger variables */
#define  REC_CHAR_UNSIGNED        0x0002
#define  REC_CHAR_SIGNED          0x0003
#define  REC_WORD_UNSIGNED        0x0004
#define  REC_WORD_SIGNED          0x0005
#define  REC_LONG_UNSIGNED        0x0008
#define  REC_LONG_SIGNED          0x0009

/*--------------------------------------
    Macros
  --------------------------------------*/
  /* save data for response to PC */
#define respPrepare(sts, len) {response.status = sts; response.length = len;}

/* application command call status */
static unsigned char pcmdrvAppCmdSts;

#define Inhr7_OUT_BUF_SIZE  0x40       /* Length of the TX buffer */
static int8_t pcm_out_buffer[Inhr7_OUT_BUF_SIZE];
static int8_t *p_pcm_out_buffer = pcm_out_buffer;

/******************************************************************************/
/*                      SCI MACROS - !!! core dependent !!!                   */
/******************************************************************************/
#define INT_DISABLE      0
#define INT_ENABLE       1
// #define SCIread(data) \
//           {Inhr7_RecvChar(&data);}
// #define SCIwrite(data) \
//           {Inhr7_SendChar(data);}
#define SCItxEmptyIsr(param) \
        {if (param==INT_ENABLE) \
                      {PC_M1_SCITxEmptyInt = INT_ENABLE;}\
         else if (param==INT_DISABLE) \
                      {PC_M1_SCITxEmptyInt = INT_DISABLE;} }
#define SCIrxFullIsr(param) \
        {if (param==INT_ENABLE) \
                      {PC_M1_SCIRxFullInt = INT_ENABLE;}\
         else if (param==INT_DISABLE) \
                      {PC_M1_SCIRxFullInt = INT_DISABLE;} }

/******************************************************************************/
/*                    MEMORY ACCESS - !!! core dependent !!!                  */
/******************************************************************************/
#define  POINT32_LEN    4
#define  BYTE_LEN       1
#define  WORD_LEN       2
#define  LONG_LEN       4

/********************************************************/
/* PC Master Communication protocol commands data types */
/********************************************************/

/* read variable */
typedef struct {
    unsigned char cmd;
    unsigned char addrByte[4];     /* address of variable */
} sReadVarEx;

/* response structure type (this structure is used to save
the parameters of response to be sent to PC) */
typedef struct {
    unsigned char status;          /* status byte of response */
    unsigned char length;          /* length of the whole response */
} sResponse;

/* standard commands */
/* read memory */
typedef struct {
    unsigned char cmd;
    unsigned char cmdLen;
    unsigned char size;            /* size of data block in bytes */
    unsigned char addrByte[4];     /* address of data */
} sReadMemEx;

/* write memory */
typedef struct {
    unsigned char cmd;
    unsigned char cmdLen;
    unsigned char size;            /* size of data block in bytes */
    unsigned char addrByte[4];     /* address of data */
    unsigned char data[1];         /* data */
} sWriteMemEx;

/* setup scope */
typedef struct {
    unsigned char cmd;
    unsigned char cmdLen;
    unsigned char varCnt;          /* number of variables */
    unsigned char dataByte[1];     /* address of variable */
} sSetupScopeEx;

/* setup recorder */
typedef struct {
    uint16_t  cmd;
    uint16_t  cmdLen;
    uint16_t  trgMode;
    uint16_t  totalSmps;
    uint16_t  postTrigger;
    uint16_t  timeDiv;              /* Time Base unit multiplier  */
    uint32_t  trgVarAddr[1];
    uint16_t  trgVarSize;
    uint16_t  trgVarSigned;
    union {
        uint8_t      uch;
        int8_t       ch;
        uint16_t     uw;
        int16_t      sw;
        uint32_t     ud;
        long         sd;
    } trgThreshold;                /* trigger comparing threshold */
    uint16_t        varCnt;         /* number of variables */
    struct {
        uint16_t     varSize;       /* size of variable in bytes */
        uint32_t     varAddr[1];    /* address of variable    */
    } varDef[8];
} sSetupRec;

/* call user application command */
typedef struct {
    uint8_t       cmd;
    uint8_t       cmdLen;
    uint8_t       appCmdData[1];     /* application command data */
} sCallAppCmd;

/* return any data */
typedef struct {
    unsigned char reserved;        /* status code */
    unsigned char data[1];         /* data to PC */
} sReturnData;

/* currently read input char (it contains checksum at the end of message) */
static uint8_t inChar;
/* position in buffer (0,1,2,...) */
static unsigned short pos;
/* length of data in a message used for receiving and transmitting (includes checksum) */
static uint8_t length;

/* variable for checksum accumulation */
static unsigned short checkSum;

/* pointer to sciComm structure passed in initialization */
static sPCMasterComm *PCMasterComm;

static sResponse response;             /* variable with response data */

static uint16_t recPretrigCount;        /* recorder pretrigger counter   */

/* prepare data for transmitting
(response.status -> status code, len -> length of data) */
static void sendResponse(sResponse *resp);
/* sample recorder data */
//static asm void readSample(int *Addr, int *DestAddr);
static uint16_t readRecSample(uint16_t position);
/* decoding of incoming message after the last byte was received */
static void messageDecode(void);

/* routine callled after filtering doubled SOM */
static void messageData(uint16_t startOfMessage);
/* all functions that begins with Cmd execute
   the command and place the right data in dataBuff */
   //__inline static void cmdGetInfoBrief(void);
static uint16_t memCopy(register volatile unsigned char * srcAddr,
    register volatile unsigned char * destAddr,
    register volatile signed char size);
/*---------------------------------------
  SCI communication algotithm variables
  --------------------------------------- */
static unsigned short status;            /* status word of receiver */


/*
** ===================================================================
**     Method      :  PC_M1_pcmasterdrvInit (bean PC_Master)
**
**     Description :
**         Initialization of PC Master Communication Algorithm. This
**         function must be called first, before start of
**         communication.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * p_sPCMasterComm - Pointer to
**                           structure with SCI communication
**                           settings.
**     Returns     :
**         ---             - The function returns the PASS (0).
** ===================================================================
*/
int16_t PC_M1_pcmasterdrvInit(sPCMasterComm *p_sPCMasterComm)
{
    /* store sPCMasterComm structure address */
    PCMasterComm = (sPCMasterComm *)p_sPCMasterComm;

    inChar = 1;
    status = 0; /* reset receiver */

#ifdef PCMDRV_INCLUDE_CMD_SCOPE
  /* reset scope */
    ((pcmdrv_sScope *)(PCMasterComm->p_scope))->varCnt = 0;
#endif

#ifdef PCMDRV_INCLUDE_CMD_RECORDER
    /* reset recorder */
    ((pcmdrv_sScope *)(PCMasterComm->p_recorder))->varCnt = 0;
#endif

#ifdef PCMDRV_INCLUDE_CMD_APPCMD
    /* initialize application command status */
    pcmdrvAppCmdSts = PCMDRV_APPCMD_NOCMD;
#endif

    return(0);
}

void put_char(char c)
{
    inChar = c;
    if ((status & ST_ST_CHAR_REC) == 0) { /* last byte was not '+' */
        if (inChar == '+') {               /* '+' received */
            bitSet(ST_ST_CHAR_REC, status);
        }
        else {                             /* any byte received */
            messageData(0);                  /* byte received */
        }
    }
    else {                               /* the last byte was '+' */
        if (inChar == '+') {               /* doubled '+' (this is the second one) */
            messageData(0);                  /* byte received */
        }
        else {                             /* start of message */
            messageData(1);                  /* byte received */
        }
        bitClear(ST_ST_CHAR_REC, status);   /* clear flag */
    }
}

void pcmaster_write(const char * buffer, int offset, int length)
{
    buffer += offset;
    while (length--)
    {
        put_char(*buffer++);
    }
}

/*
** ===================================================================
**     Method      :  pcmaster_record (bean PC_Master)
**
**     Description :
**         Recorder Routine. It performs sampling of data into
**         buffer which is located on the address p_recBuff item is
**         pointing and its length is determined by recSize item in
**         the initialization structure of sPCMasterComm type.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void pcmaster_record(void)
{
    volatile union {
        uint8_t      uch;
        int8_t       ch;
        uint16_t     uw;
        int16_t      sw;
        uint32_t     ud;
        long         sd;
    } actual;

    if (status & ST_RECACTIVATED) {      /* recorder activated */
        if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime ==
            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->timeDiv) { /* now is the right time to make samples  */
            if (!(ST_REC_READ_PRETRIG & status)) {
                if (recPretrigCount >= (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->totalSmps -
                    (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recSetLen *
                        ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger)))
                    bitSet(ST_REC_READ_PRETRIG, status);
                else recPretrigCount += ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recSetLen;
            }
            /* read actual trigger value  */
            memCopy((uint8_t*)(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgVarAddr[0]),
                (uint8_t*)(&actual.uch), (int8_t)(((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSize));
            /* read new samples  */
            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recPos =
                readRecSample(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recPos);
            /* wrap around */
            if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recPos >=
                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->totalSmps)
                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recPos = 0;
            switch (status & 0x000f) {
            case REC_CHAR_UNSIGNED: {    /* size=1, unsigned char   */
                if ((!(status & ST_RECRUNNING)) && (status & ST_REC_READ_PRETRIG)) {
                    if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGRIS) &&
                        (actual.uch >= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.uch) &&
                        (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.uch <
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.uch)) {
                        /* recorder is configured to rising edge actual value       */
                        /* greater than threshold last value smaller than threshold */
                        bitSet(ST_RECRUNNING, status);
                        ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger - 1;
                    }
                    else
                        if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGFAL) &&
                            (actual.uch <= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.uch) &&
                            (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.uch >
                                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.uch)) {
                            /* recorder is configured to falling edge actual value      */
                            /* smaller than Threshold last value greater than Threshold */
                            bitSet(ST_RECRUNNING, status);
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
                                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger - 1;
                        }
                }
                else
                    if (status & ST_REC_READ_PRETRIG)((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd--;
                /* buffer is full */
                if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd == 0) {
                    bitClear(ST_RECRUNNING | ST_RECACTIVATED | ST_REC_READ_PRETRIG, status);
                    ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd = 1;
                }
                /* remember last value  */
                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.uch = actual.uch;
                /* reset recorder time  */
                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime = 0;
            }break;
            case REC_CHAR_SIGNED: {      /* size=1,  signed  char   */
                if ((!(status & ST_RECRUNNING)) && (status & ST_REC_READ_PRETRIG)) {
                    if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGRIS) &&
                        (actual.ch >= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.ch) &&
                        (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.ch <
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.ch)) {
                        /* recorder is configured to rising edge actual value       */
                        /* greater than threshold last value smaller than threshold */
                        bitSet(ST_RECRUNNING, status);
                        ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger - 1;
                    }
                    else
                        if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGFAL) &&
                            (actual.ch <= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.ch) &&
                            (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.ch >
                                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.ch)) {
                            /* recorder is configured to falling edge actual value      */
                            /* smaller than Threshold last value greater than Threshold */
                            bitSet(ST_RECRUNNING, status);
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
                                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger - 1;
                        }
                }
                else
                    if (status & ST_REC_READ_PRETRIG)((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd--;
                /* buffer is full */
                if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd == 0) {
                    bitClear(ST_RECRUNNING | ST_RECACTIVATED | ST_REC_READ_PRETRIG, status);
                    ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd = 1;
                }
                /* remember last value  */
                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.ch = actual.ch;
                /* reset recorder time  */
                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime = 0;
            }break;
            case REC_WORD_UNSIGNED: {    /* size=2, unsigned word  */
                if ((!(status & ST_RECRUNNING)) && (status & ST_REC_READ_PRETRIG)) {
                    if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGRIS) &&
                        (actual.uw >= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.uw) &&
                        (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.uw <
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.uw)) {
                        /* recorder is configured to rising edge actual value       */
                        /* greater than threshold last value smaller than threshold */
                        bitSet(ST_RECRUNNING, status);
                        ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger - 1;
                    }
                    else
                        if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGFAL) &&
                            (actual.uw <= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.uw) &&
                            (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.uw >
                                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.uw)) {
                            /* recorder is configured to falling edge actual value      */
                            /* smaller than Threshold last value greater than Threshold */
                            bitSet(ST_RECRUNNING, status);
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
                                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger - 1;
                        }
                }
                else
                    if (status & ST_REC_READ_PRETRIG)((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd--;
                /* buffer is full */
                if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd == 0) {
                    bitClear(ST_RECRUNNING | ST_RECACTIVATED | ST_REC_READ_PRETRIG, status);
                    ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd = 1;
                }
                /* remember last value  */
                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.uw = actual.uw;
                /* reset recorder time   */
                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime = 0;
            }break;
            case REC_WORD_SIGNED: {      /* size=2, signed word */
                if ((!(status & ST_RECRUNNING)) && (status & ST_REC_READ_PRETRIG)) {
                    if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGRIS) &&
                        (actual.sw >= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.sw) &&
                        (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.sw <
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.sw)) {
                        /* recorder is configured to rising edge actual value       */
                        /* greater than threshold last value smaller than threshold */
                        bitSet(ST_RECRUNNING, status);
                        ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger - 1;
                    }
                    else
                        if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGFAL) &&
                            (actual.sw <= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.sw) &&
                            (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.sw >
                                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.sw)) {
                            /* recorder is configured to falling edge actual value      */
                            /* smaller than Threshold last value greater than Threshold */
                            bitSet(ST_RECRUNNING, status);
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
                                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger - 1;
                        }
                }
                else
                    if (status & ST_REC_READ_PRETRIG)((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd--;
                /* buffer is full */
                if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd == 0) {
                    bitClear(ST_RECRUNNING | ST_RECACTIVATED | ST_REC_READ_PRETRIG, status);
                    ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd = 1;
                }
                /* remember last value  */
                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.sw = actual.sw;
                /* reset recorder time   */
                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime = 0;
            }break;
            case REC_LONG_UNSIGNED: {    /* size=4, unsigned double word  */
                if ((!(status & ST_RECRUNNING)) && (status & ST_REC_READ_PRETRIG)) {
                    if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGRIS) &&
                        (actual.ud >= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.ud) &&
                        (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.ud <
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.ud)) {
                        /* recorder is configured to rising edge actual value       */
                        /* greater than threshold last value smaller than threshold */
                        bitSet(ST_RECRUNNING, status);
                        ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger - 1;
                    }
                    else
                        if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGFAL) &&
                            (actual.ud <= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.ud) &&
                            (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.ud >
                                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.ud)) {
                            /* recorder is configured to falling edge actual value      */
                            /* smaller than Threshold last value greater than Threshold */
                            bitSet(ST_RECRUNNING, status);
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
                                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger - 1;
                        }
                }
                else
                    if (status & ST_REC_READ_PRETRIG)((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd--;
                /* buffer is full */
                if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd == 0) {
                    bitClear(ST_RECRUNNING | ST_RECACTIVATED | ST_REC_READ_PRETRIG, status);
                    ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd = 1;
                }
                /* remember last value  */
                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.ud = actual.ud;
                /* reset recorder time   */
                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime = 0;
            }break;
            case REC_LONG_SIGNED: {      /* size=4,   signed double word  */
                if ((!(status & ST_RECRUNNING)) && (status & ST_REC_READ_PRETRIG)) {
                    if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGRIS) &&
                        (actual.sd >= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.sd) &&
                        (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.sd <
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.sd)) {
                        /* recorder is configured to rising edge actual value       */
                        /* greater than threshold last value smaller than threshold */
                        bitSet(ST_RECRUNNING, status);
                        ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger - 1;
                    }
                    else
                        if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGFAL) &&
                            (actual.sd <= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.sd) &&
                            (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.sd >
                                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.sd)) {
                            /* recorder is configured to falling edge actual value      */
                            /* smaller than Threshold last value greater than Threshold */
                            bitSet(ST_RECRUNNING, status);
                            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
                                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger - 1;
                        }
                }
                else
                    if (status & ST_REC_READ_PRETRIG)((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd--;
                /* buffer is full */
                if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd == 0) {
                    bitClear(ST_RECRUNNING | ST_RECACTIVATED | ST_REC_READ_PRETRIG, status);
                    ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd = 1;
                }
                /* remember last value  */
                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.sd = actual.sd;
                /* reset recorder time   */
                ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime = 0;
            }break;
            }
        }
        else {
            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime++;
        }
    }
    else {                               /* recorder not activated */
        recPretrigCount = 0;
        bitClear(ST_REC_READ_PRETRIG, status);
    }
}

/*
** ===================================================================
**     Method      :  memCopy (bean PC_Master)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint16_t memCopy(register volatile char unsigned *srcAddr,
    register volatile unsigned char *destAddr,
    register volatile signed char size)
{
    while ((--size) >= 0) {
        *destAddr++ = *srcAddr++;
    }
    return(0);
}
static void (*pc_master_send)(const char * , int);

static void sendResponse(sResponse *pRespones)
{
    int add_length = 0;
    (PCMasterComm)->p_dataBuff[0] = pRespones->status;
    length = pRespones->length;
    if (pRespones->length > 10)
    {
        length = pRespones->length;
    }
    pos = 0;
    checkSum = 0;
    *p_pcm_out_buffer++ = '+';

    while (length--)
    {
        *p_pcm_out_buffer++ = (PCMasterComm)->p_dataBuff[pos];
        if ((PCMasterComm)->p_dataBuff[pos] == 0x2b)
        {
            *p_pcm_out_buffer++ = 0x2b;
            add_length++;
        }
        checkSum += (PCMasterComm)->p_dataBuff[pos];
        pos++;
    }
    checkSum = (-checkSum) & 0x00ff;
    *p_pcm_out_buffer++ = checkSum;
    if (checkSum == 0x2b)
    {
        *p_pcm_out_buffer++ = 0x2b;
        add_length++;
    }

    p_pcm_out_buffer = pcm_out_buffer;
    if(pc_master_send != 0x0)
    {
        pc_master_send((char *)pcm_out_buffer, pRespones->length + 2 + add_length);	  //1+1checksum
    }
}

/*
** ===================================================================
**     Method      :  messageDecode (bean PC_Master)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void messageDecode(void)
{
    unsigned char *varaddr;
#ifndef PCMDRV_INCLUDE_CMD_GETINFOBRIEF
    unsigned char cnt;
#endif

    switch (PCMasterComm->p_dataBuff[0]) {
        /* -------------------------
        special format commands
        ------------------------- */
    case PCMDRV_CMD_READVAR8EX: {      /* read 8-bit variable */
        /* read address */
        memCopy(((sReadVarEx *)(PCMasterComm->p_dataBuff))->addrByte,
            (unsigned char *)&varaddr, POINT32_LEN);
        /* read data */
        memCopy(varaddr, ((sReturnData *)(PCMasterComm->p_dataBuff))->data, BYTE_LEN);
        respPrepare(PCMDRV_STC_OK, 2); /* OK */
    }break;
    case PCMDRV_CMD_READVAR16EX: {     /* read 16-bit variable */
        /* read address */
        memCopy(((sReadVarEx *)(PCMasterComm->p_dataBuff))->addrByte,
            (unsigned char *)&varaddr, POINT32_LEN);
        /* read data */
        memCopy(varaddr, ((sReturnData *)(PCMasterComm->p_dataBuff))->data, WORD_LEN);
        respPrepare(PCMDRV_STC_OK, 3); /* OK */
    }break;
    case PCMDRV_CMD_READVAR32EX: {     /* read 32-bit variable */
        /* read address */
        memCopy(((sReadVarEx *)(PCMasterComm->p_dataBuff))->addrByte,
            (unsigned char *)&varaddr, POINT32_LEN);
        /* read data */
        memCopy(varaddr, ((sReturnData *)(PCMasterComm->p_dataBuff))->data, LONG_LEN);
        respPrepare(PCMDRV_STC_OK, 5); /* OK */
    }break;
#ifdef PCMDRV_INCLUDE_CMD_SCOPE
    case PCMDRV_CMD_READSCOPE: {       /* read scope variables */
        unsigned char i, cnt, index = 0;
        /* scope not configured */
        if (((pcmdrv_sScope *)(PCMasterComm->p_scope))->varCnt == 0) {
            respPrepare(PCMDRV_STC_NOTINIT, 1); /* scope not initialized */
        }
        else {                         /* scope configured */
          /* read number of variables */
            cnt = ((pcmdrv_sScope *)(PCMasterComm->p_scope))->varCnt;
            for (i = 0; i < cnt; i++) {
                /* read size of variable */
                length = ((pcmdrv_sScope *)(PCMasterComm->p_scope))->varDef[i].varSize;
                /* read address of variable */
                memCopy(((pcmdrv_sScope *)(PCMasterComm->p_scope))->varDef[i].addrByte,
                    (unsigned char *)&varaddr, POINT32_LEN);
                /* copy data into the input/output buffer */
                memCopy(varaddr, (unsigned char *)&((sReturnData *)
                    (PCMasterComm->p_dataBuff))->data[index], (int8_t)length);
                index += length;
            }
            respPrepare(PCMDRV_STC_OK, (uint8_t)(index + 1)); /* OK */
        }
    }break;
#endif
#ifdef PCMDRV_INCLUDE_CMD_APPCMD
    case PCMDRV_CMD_GETAPPCMDSTS: {    /* get user application command call status */
        /* buffer is not initialized (zero length) */
        if (PCMasterComm->appCmdSize == 0) {
            respPrepare(PCMDRV_STC_INVCMD, 1); /* invalid command */
            return;
        }
        /* copy status byte in the output buffer */
        ((sReturnData *)(PCMasterComm->p_dataBuff))->data[0] = pcmdrvAppCmdSts;
        respPrepare(PCMDRV_STC_OK, 2);   /* OK */
    }break;
#endif
#ifdef PCMDRV_INCLUDE_CMD_GETINFOBRIEF
    case PCMDRV_CMD_GETINFOBRIEF: {    /* get brief info about hardware */
        cmdGetInfoBrief();             /* execute the command */
        respPrepare(PCMDRV_STC_OK, (1 + 6)); /* OK */
    }break;
#endif
#ifndef PCMDRV_INCLUDE_CMD_GETINFOBRIEF
    case PCMDRV_CMD_GETINFO: {         /* get info about hardware */
        /* protocol version  */
        ((sReturnData *)(PCMasterComm->p_dataBuff))->data[0] = PCMDRV_PROT_VER;
        /* CFG_FLAFGS  */
        ((sReturnData *)(PCMasterComm->p_dataBuff))->data[1] = PCMDRV_CFG_FLAFGS;
        /* dataBusWdt  */
        ((sReturnData *)(PCMasterComm->p_dataBuff))->data[2] = PCMDRV_DATABUSWDT;
        /* version  */
        ((sReturnData *)(PCMasterComm->p_dataBuff))->data[3] = PCMasterComm->globVerMajor;
        /* version  */
        ((sReturnData *)(PCMasterComm->p_dataBuff))->data[4] = PCMasterComm->globVerMinor;
        /* size of input buffer (without CMD, LENGTH)   */
        ((sReturnData *)(PCMasterComm->p_dataBuff))->data[5] = (uint8_t)(((PCMasterComm->dataBuffSize) - 1));
        /* recorder buff size   */
        ((sReturnData *)(PCMasterComm->p_dataBuff))->data[6] = (uint8_t)((PCMasterComm->recSize) & 0x00ff);
        ((sReturnData *)(PCMasterComm->p_dataBuff))->data[7] = (uint8_t)(((PCMasterComm->recSize) >> 8) & 0x00ff);
        /* period of Recorder routine launch   */
        ((sReturnData *)(PCMasterComm->p_dataBuff))->data[8] = (uint8_t)((PCMasterComm->timeBase) & 0x00ff);
        ((sReturnData *)(PCMasterComm->p_dataBuff))->data[9] = (uint8_t)(((PCMasterComm->timeBase) >> 8) & 0x00ff);
        /* copy identification string */
        for (cnt = 0; cnt < PCMDRV_IDT_STRING_LEN; cnt++) {
            ((sReturnData *)((PCMasterComm)->p_dataBuff))->data[10 + cnt] = PCMasterComm->idtString[cnt];
        }
        /* OK */
        respPrepare(PCMDRV_STC_OK, (1 + 10 + PCMDRV_IDT_STRING_LEN));
    }break;
#endif
#ifdef PCMDRV_INCLUDE_CMD_RECORDER
    case PCMDRV_CMD_STARTREC: {        /* start recorder */
        if (PCMasterComm->recSize == 0) { /* recorder not implemented  */
            respPrepare(PCMDRV_STC_INVCMD, 1); /* invalid command */
            return;
        }
        if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->varCnt) { /* recorder initialized      */
            if (!(status & ST_RECRUNNING)) { /* recorder not running      */
                bitClear(ST_RECRUNNING, status); /* stop recorder if it is running   */
                (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime) = /* initialize time div       */
                    ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->timeDiv; /* addr. of triggering variable  */
                varaddr = (unsigned char*)(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgVarAddr);
                memCopy((uint8_t*)(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgVarAddr[0]),
                    (uint8_t*)(&(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.ud)),
                    (int8_t)(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgVarSize));
                bitSet(ST_RECACTIVATED, status); /* activate recorder to wait for trigger */
                respPrepare(PCMDRV_STC_OK, 1); /* OK */
            }
            else {
                respPrepare(PCMDRV_STC_RECRUN, 1); /* recorder is running  */
            }
        }
        else {                         /* recorder is not initialized   */
            respPrepare(PCMDRV_STC_NOTINIT, 1); /* recorder not initialized   */
        }
    }break;
#endif
#ifdef PCMDRV_INCLUDE_CMD_RECORDER /* start recorder */
    case PCMDRV_CMD_STOPREC: {         /* stop recorder  */
        if (PCMasterComm->recSize == 0) { /* recorder not implemented   */
            respPrepare(PCMDRV_STC_INVCMD, 1); /* invalid command   */
            return;
        }
        if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->varCnt) { /* recorder initialized */
            if (status & ST_RECACTIVATED) { /* recorder activated   */
                if (status & ST_RECRUNNING) { /* recorder running     */
                    respPrepare(PCMDRV_STC_RECDONE, 1); /* recorder finished    */
                }
                else {                     /* recorder not running */
                  /* initialize posttrigger value  */
                    (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd) =
                        (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger);
                    bitSet(ST_RECRUNNING, status); /* manually trigger the recorder */
                    respPrepare(PCMDRV_STC_OK, 1); /* OK */
                }
            }
            else {                       /* recorder not activated  */
                respPrepare(PCMDRV_STC_RECDONE, 1); /* recorder finished       */
            }
        }
        else {                         /* recorder not initialized*/
            respPrepare(PCMDRV_STC_NOTINIT, 1);
        }
    }break;
#endif
#ifdef PCMDRV_INCLUDE_CMD_RECORDER /* start recorder          */
    case PCMDRV_CMD_GETRECBUFFEX: {    /* get recorder buffer     */
        uint16_t        tmp;            /* temporary variable      */

        if (PCMasterComm->recSize == 0) { /* recorder not implemented*/
            respPrepare(PCMDRV_STC_INVCMD, 1);
            return;
        }
        if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->varCnt) != 0) { /* recorder initialized */
            if (!(status & ST_RECRUNNING)) { /* recorder not running */
              /* recorder buffer address */
                memCopy((uint8_t*)(&(PCMasterComm->p_recBuff)), (uint8_t*)(&(PCMasterComm->p_dataBuff[1])), LONG_LEN);
                tmp = (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recPos) /
                    (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recSetLen);
                (PCMasterComm)->p_dataBuff[5] = (uint8_t)(tmp & 0x00FF); /* position of the last sample in rec.buff. LSB */
                (PCMasterComm)->p_dataBuff[6] = (uint8_t)(tmp >> 8); /* position of the last sample in rec.buff. MSB */
                respPrepare(PCMDRV_STC_OK, 7); /* OK */
            }
            else {                       /* recorder running  */
                respPrepare(PCMDRV_STC_SERVBUSY, 1); /*  service busy     */
            }
        }
        else {                         /* recorder initialized */
            respPrepare(PCMDRV_STC_NOTINIT, 1); /* recorder not initialized   */
        }
    }break;
#endif
#ifdef PCMDRV_INCLUDE_CMD_RECORDER /* recorder status            */
    case PCMDRV_CMD_GETRECSTS: {       /* get recorder status        */
        if (PCMasterComm->recSize == 0) { /* recorder not implemented   */
            respPrepare(PCMDRV_STC_INVCMD, 1); /* invalid command            */
            return;
        }
        if (((pcmdrv_sScope *)(PCMasterComm->p_recorder))->varCnt) { /* recorder is initialized    */
            if (!(status & ST_RECACTIVATED)) {
                respPrepare(PCMDRV_STC_RECDONE, 1); /* recorder finished          */
            }
            else {
                respPrepare(PCMDRV_STC_RECRUN, 1); /* recorder running           */
            }
        }
        else {                         /* recorder is not initialized*/
            respPrepare(PCMDRV_STC_NOTINIT, 1); /* recorder not initialized   */
        }
    }break;
#endif
        /* --------------------------
            standard format commands
           -------------------------- */
#ifdef PCMDRV_INCLUDE_CMD_SCOPE
    case PCMDRV_CMD_SETUPSCOPEEX: {    /* setup scope */
        unsigned char cnt, i;

        cnt = (((sSetupScopeEx *)(PCMasterComm->p_dataBuff))->varCnt);
        if ((cnt == 0) || (cnt > 8)) {
            /* varCnt is zero or greater than 8 */
            respPrepare(PCMDRV_STC_INVBUFF, 1); /* invalid buffer size */
            return;
        }
        /* read varCnt */
        ((pcmdrv_sScope *)(PCMasterComm->p_scope))->varCnt = cnt;
        for (i = 0; i < cnt; i++) {
            /* read size of variable */
            ((pcmdrv_sScope *)(PCMasterComm->p_scope))->varDef[i].varSize =
                ((sSetupScopeEx *)(PCMasterComm->p_dataBuff))->dataByte[i * 5];
            /* read address of variable */
            memCopy((unsigned char *)&((sSetupScopeEx *)
                (PCMasterComm->p_dataBuff))->dataByte[1 + 5 * i],
                ((pcmdrv_sScope *)(PCMasterComm->p_scope))->
                varDef[i].addrByte, POINT32_LEN);
        }
        /* check size of variable s */
        for (i = 0; i < (((pcmdrv_sScope *)(PCMasterComm->p_scope))->varCnt); i++) {
            /* varSize is 0,3 or greater than 4 */
            if (((((pcmdrv_sScope *)(PCMasterComm->p_scope))->varDef[i].varSize) == 0) || \
                ((((pcmdrv_sScope *)(PCMasterComm->p_scope))->varDef[i].varSize) == 3) || \
                ((((pcmdrv_sScope *)(PCMasterComm->p_scope))->varDef[i].varSize) > 4)) {
                /* invalid size of variable */
                respPrepare(PCMDRV_STC_INVSIZE, 1);
                /* reset scope */
                (((pcmdrv_sScope *)(PCMasterComm->p_scope))->varCnt) = 0;
                return;
            }
        }
        respPrepare(PCMDRV_STC_OK, 1);
    }break;
#endif
#ifdef PCMDRV_INCLUDE_CMD_RECORDER
    case PCMDRV_CMD_SETUPRECEX: {
        unsigned char i;               /* auxiliariy variables definition   */

        if (PCMasterComm->recSize == 0) { /* recorder not implemented  */
            respPrepare(PCMDRV_STC_INVCMD, 1); /* invalid command  */
            return;
        }
        /* reset the recorder */
        bitClear(ST_RECRUNNING | ST_RECACTIVATED, status);
        /* initialize recorder*/
        /* (copy data from dataBuff to Recorder structure) => copy structure form PCMasterComm->p_dataBuff to */
        /* PCMasterComm->p_recorder =>  copy and organize data  to recorder structure. It is necessary to do  */
        /* conversions byte variables to word by reason of arrange data to even address                       */
        /* read command             */
        ((sSetupRec *)(PCMasterComm->p_recorder))->cmd = *((PCMasterComm->p_dataBuff) + 0);
        /* read cmdLen              */
        ((sSetupRec *)(PCMasterComm->p_recorder))->cmdLen = *((PCMasterComm->p_dataBuff) + 1);
        /* read trigger mode        */
        ((sSetupRec *)(PCMasterComm->p_recorder))->trgMode = *((PCMasterComm->p_dataBuff) + 2);
        if (((sSetupRec *)(PCMasterComm->p_recorder))->trgMode > 2) { /* test value {0,1,2}       */
            respPrepare(PCMDRV_STC_INVBUFF, 1); /* invalid trigger mode     */
            return;
        }
        /* read total samples        */
        memCopy((PCMasterComm->p_dataBuff) + 3,
            (uint8_t*)(&(((sSetupRec *)(PCMasterComm->p_recorder))->totalSmps)), WORD_LEN);
        /* read post tiger size      */
        memCopy((PCMasterComm->p_dataBuff) + 5,
            (uint8_t*)(&(((sSetupRec *)(PCMasterComm->p_recorder))->postTrigger)), WORD_LEN);
        /* read timeDiv             */
        memCopy((PCMasterComm->p_dataBuff) + 7,
            (uint8_t*)(&(((sSetupRec *)(PCMasterComm->p_recorder))->timeDiv)), WORD_LEN);
        /* read trig. variab. address*/
        memCopy((PCMasterComm->p_dataBuff) + 9,
            (uint8_t*)(&(((sSetupRec *)(PCMasterComm->p_recorder))->trgVarAddr[0])), POINT32_LEN);
        /* read trig. variab. size   */
        ((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSize = *((PCMasterComm->p_dataBuff) + 13);
        if (!((((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSize == 1) || /* test trig. variab. size   */
            (((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSize == 2) ||
            (((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSize == 4))) {
            respPrepare(PCMDRV_STC_INVSIZE, 1); /* invalid buffer size       */
            (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->varCnt) = 0;
            return;
        }
        /* read trig. compare mode    */
        ((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSigned = *((PCMasterComm->p_dataBuff) + 14);
        memCopy((PCMasterComm->p_dataBuff) + 15,
            (uint8_t*)(&(((sSetupRec *)(PCMasterComm->p_recorder))->trgThreshold.ud)), LONG_LEN);
        /* read variable definitions  */
        ((sSetupRec *)(PCMasterComm->p_recorder))->varCnt = *((PCMasterComm->p_dataBuff) + 19);
        if ((((sSetupRec *)(PCMasterComm->p_recorder))->varCnt == 0) || /* testing of data correctness*/
            (((sSetupRec *)(PCMasterComm->p_recorder))->varCnt > 8)) {
            respPrepare(PCMDRV_STC_INVBUFF, 1); /* if varCnt is zero or greater than 8 => invalid buffer size */
            (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->varCnt) = 0;
            return;
        }
        status = (status & 0xfff0) | ((((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSize) << 1) +
            ((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSigned; /* set status                 */
        for (i = 0; i < ((sSetupRec *)(PCMasterComm->p_recorder))->varCnt; i++) { /* data descriptions => scope */
          /* initialization             */
          /* read variable size         */
            ((sSetupRec *)(PCMasterComm->p_recorder))->varDef[i].varSize = *((PCMasterComm->p_dataBuff) + 20 + i * 5);
            if ((((sSetupRec *)(PCMasterComm->p_recorder))->varDef[i].varSize == 0) ||
                (((sSetupRec *)(PCMasterComm->p_recorder))->varDef[i].varSize == 3)) { /* test variable sizes        */
                respPrepare(PCMDRV_STC_INVSIZE, 1); /* invalid buffer size        */
                (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->varCnt) = 0;
                return;
            }
            memCopy((PCMasterComm->p_dataBuff) + 21 + i * 5,
                (uint8_t*)(&(((sSetupRec *)(PCMasterComm->p_recorder))->varDef[i].varAddr[0])), POINT32_LEN);
        }
        /*  next samples position in recorder buffer - incremented by RecSetLen */
        status = (status & 0xfff0) | ((((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSize) << 1) +
            ((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSigned; /* set status                 */
        ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recPos = 0;
        /*  length of requiered variables set [Word] */
        ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recSetLen = 0;
        /*  position to end of buffer */
        ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd = 1;
        /*  recorder time div         */
        ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime =
            ((sSetupRec *)(PCMasterComm->p_recorder))->timeDiv;
        /* check if recorder buffer size is valid */
        ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recSetLen = 0; /* clear result before cycle  */
        for (i = 0; i < ((sSetupRec *)(PCMasterComm->p_recorder))->varCnt; i++) { /* get one set of samples [B] */
            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recSetLen +=
                ((sSetupRec *)(PCMasterComm->p_recorder))->varDef[i].varSize;
        }
        ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->totalSmps *= /* required buffer size [W]   */
            ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recSetLen;
        if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->totalSmps <= /* required buffer size is    */
            PCMasterComm->recSize) { /* smaller than record. buffer*/
              /* read last value of trig. variable   */
            memCopy((uint8_t*)(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgVarAddr[0]),
                (uint8_t*)(&(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.ud)),
                (int8_t)(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgVarSize));
            respPrepare(PCMDRV_STC_OK, 1);
            bitSet(ST_RECACTIVATED, status); /* recorder activated  */
        }
        else {
            respPrepare(PCMDRV_STC_INVSIZE, 1); /* invalid buffer size */
            (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->varCnt) = 0;
            return;
        }
    }break;
#endif
    case PCMDRV_CMD_READMEMEX: {       /* read block of memory */
        /* read size of data */
        memCopy(&(((sReadMemEx *)(PCMasterComm->p_dataBuff))->size),
            (unsigned char *)&length, BYTE_LEN);
        if (length <= ((PCMasterComm)->dataBuffSize)) {
            /* read address */
            memCopy(((sReadMemEx *)(PCMasterComm->p_dataBuff))->addrByte,
                (unsigned char *)&varaddr, POINT32_LEN);
            /* copy data */
            memCopy(varaddr, (((sReturnData *)(PCMasterComm->p_dataBuff))->data), (int8_t)length);
            respPrepare(PCMDRV_STC_OK, (uint8_t)(length + 1)); /* OK */
        }
        else {
            /* response greater than buffer */
            /* response buffer overflow */
            respPrepare(PCMDRV_STC_RSPBUFFOVF, 1);
        }
    }break;
    case PCMDRV_CMD_WRITEMEMEX: {      /* write block of memory */
        /* read length of memory block from the message */
        memCopy(&(((sWriteMemEx *)(PCMasterComm->p_dataBuff))->size),
            (unsigned char *)&length, BYTE_LEN);
        /* read address */
        memCopy((((sWriteMemEx *)(PCMasterComm->p_dataBuff))->addrByte),
            (unsigned char *)&varaddr, POINT32_LEN);
        /* copy data */
        memCopy((((sWriteMemEx *)(PCMasterComm->p_dataBuff))->data),
            varaddr, (int8_t)length);
        respPrepare(PCMDRV_STC_OK, 1);
    }break;
    case PCMDRV_CMD_WRITEMEMMASKEX: {  /* write to memory with mask */
        unsigned char i, tmpData;

        /* read length of memory block from the message */
        memCopy(&(((sWriteMemEx *)(PCMasterComm->p_dataBuff))->size),
            (unsigned char *)&length, BYTE_LEN);
        /* read address */
        memCopy((((sWriteMemEx *)(PCMasterComm->p_dataBuff))->addrByte),
            (unsigned char *)&varaddr, POINT32_LEN);
        for (i = 0; i < length; i++) {
            /* read data */
            tmpData = ((sWriteMemEx *)(PCMasterComm->p_dataBuff))->data[i]; /* read data */
            tmpData &= ((sWriteMemEx *)(PCMasterComm->p_dataBuff))->data[i + length]; /* read mask */
  //          archDisableInt();
            tmpData |= (*varaddr) & ~(((sWriteMemEx *)(PCMasterComm->p_dataBuff))->data[i + length]);
            *varaddr = tmpData;          /* write back modified data */
  //          archEnableInt();
        }
        respPrepare(PCMDRV_STC_OK, 1);  /* OK */
    }break;
#ifdef PCMDRV_INCLUDE_CMD_APPCMD
    case PCMDRV_CMD_CALLAPPCMD: {      /* call user application command */
        if (PCMasterComm->appCmdSize == 0) { /* buffer is not initialized (zero length) */
            respPrepare(PCMDRV_STC_INVCMD, 1); /* invalid command */
            break;
        }
        memCopy((unsigned char *)&(((sCallAppCmd *)(PCMasterComm->p_dataBuff))->cmdLen),
            (unsigned char *)&length, BYTE_LEN);
        if (length > PCMasterComm->appCmdSize) { /* check Application Command length */
            respPrepare(PCMDRV_STC_INVBUFF, 1); /* invalid buffer size */
        }
        else {
            if (pcmdrvAppCmdSts == PCMDRV_APPCMD_RUNNING) { /* Application Command already called */
                respPrepare(PCMDRV_STC_SERVBUSY, 1); /* service is busy  */
            }
            else {                       /* no Application Command was called */
              /* copy Application Command data to Application Command buffer */
                memCopy((((sCallAppCmd *)(PCMasterComm->p_dataBuff))->appCmdData),
                    PCMasterComm->p_appCmdBuff, (int8_t)length);
                pcmdrvAppCmdSts = PCMDRV_APPCMD_RUNNING;
                respPrepare(PCMDRV_STC_OK, 1); /* OK */
            }
        }
    }break;
#endif
    default: {                         /* invalid command */
        respPrepare(PCMDRV_STC_INVCMD, 1); /* invalid command */
    }break;
    }
}

/*
** ===================================================================
**     Method      :  messageData (bean PC_Master)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void messageData(uint16_t startOfMessage)
{
    if (startOfMessage == 0) {           /* no start of message */
        if (status & ST_STARTED) {         /* start of message already detected */
            if (pos != length) {             /* read byte, accumulate checksum */
                (PCMasterComm)->p_dataBuff[pos] = (uint8_t)inChar;
                checkSum += inChar;            /* checksum accumulation */
                pos++;                         /* next position in buffer */
                if (status & ST_STD_CMD) {     /* inChar contains length of standard format message */
                    length = (uint8_t)(inChar + 2); /* read length of message */
                    bitClear(ST_STD_CMD, status); /* clear flag */
                    if (length > ((PCMasterComm)->dataBuffSize)) { /* command is greater than input buffer */
                      /* clear flag */
                        bitClear(ST_STARTED | ST_ST_CHAR_REC, status);
                        /* input buffer overflow */
                        respPrepare(PCMDRV_STC_CMDBUFFOVF, 1);
                        /* send response to PC */
                        sendResponse(&response);
                    }
                }
            }
            else {                           /* end of message */
                checkSum += inChar;            /* accumulate checksum */
                if ((checkSum & 0x00FF) == 0) { /* correct checksum */
                    messageDecode();
                }
                else {                         /* checksum error */
                  /* checksum error response */
                    respPrepare(PCMDRV_STC_CMDSERR, 1);
                }
                /* clear flag */
                bitClear(ST_STARTED | ST_ST_CHAR_REC, status);
                sendResponse(&response);       /* send response to PC */
            }
        }
    }
    else {                               /* start of message */
      /* reset receiver, read first byte of message */
        bitSet(ST_STARTED, status);         /* message receiving */
        /* read byte, start of checksum accumulating */
        checkSum = (PCMasterComm)->p_dataBuff[0] = (uint8_t)inChar;
        /* next position in buffer */
        pos = 1;
        /* value sufficient for standard format commands */
        length = 2;
        if (inChar >= 0xC0) {              /* special format command */
            length = (uint8_t)(((inChar & 0x30) >> 3) + 1); /* length decoding */
        }
        else {                             /* standard format command (next byte will be length of the message) */
            bitSet(ST_STD_CMD, status);       /* wait for next character */
        }
    }
}

/*
** ===================================================================
**     Method      :  readRecSample (bean PC_Master)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint16_t readRecSample(uint16_t position)
{
    int16_t i;

    for (i = 0; i < (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->varCnt); i++) { /* read each variable */
      /* read each variable */
        memCopy((uint8_t*)(((sSetupRec *)(PCMasterComm->p_recorder))->varDef[i].varAddr[0]),
            (uint8_t*)((PCMasterComm->p_recBuff) + position),
            (int8_t)(((sSetupRec *)(PCMasterComm->p_recorder))->varDef[i].varSize));
        position += ((sSetupRec *)(PCMasterComm->p_recorder))->varDef[i].varSize;
    }
    return(position);
}

/*
** ===================================================================
**     Method      :  pcmaster_init (bean PC_Master)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
sReturnData * returnData;
pcmdrv_sRecorder * pPcmdrvRecorder;
pcmdrv_sScope *  pPcmdrvScope;

void pcmaster_init(void (*send_hook)(const char *, int))
{
#if !defined(PCMDRV_BUFFER_SIZE)
#define PCMDRV_BUFFER_SIZE                         60
#endif

#if !defined(PC_MASTER_REC_BUFF_LEN)
    /* Recorder buffer length */
#define PC_MASTER_REC_BUFF_LEN                     40
#endif
#if !defined(PC_MASTER_APPCMD_BUFF_LEN)
  /* Application Command buffer length */
#define PC_MASTER_APPCMD_BUFF_LEN                   5
#endif


    static uint16_t pcmdrvDataBuff[(PCMDRV_BUFFER_SIZE / 2) + 1];
    static sPCMasterComm PCMSettings;    /* initialization structure */
    static pcmdrv_sScope pcmdrvScope;    /* scope config data */

#if (PC_MASTER_REC_BUFF_LEN != 0)
  /* recorder buffer */
    static uint16_t PCMasterCommRecorderBuffer[PC_MASTER_REC_BUFF_LEN];
    static pcmdrv_sRecorder pcmdrvRecorder; /* recorder config and temp data */
#endif
#if (PC_MASTER_APPCMD_BUFF_LEN != 0)
  /* application command data buffer */
    static unsigned char PCMasterAppCmdBuff[PC_MASTER_APPCMD_BUFF_LEN];
#endif
#if (PC_MASTER_REC_BUFF_LEN != 0)
    /* address of buffer */
    PCMSettings.p_recBuff = (unsigned char *)PCMasterCommRecorderBuffer;
    PCMSettings.p_recorder = (unsigned char *)&pcmdrvRecorder;
    pPcmdrvRecorder = &pcmdrvRecorder;
    returnData = (sReturnData *)PCMasterComm->p_dataBuff;
    pPcmdrvScope = &pcmdrvScope;
#endif

    /* address of input/output buffer */
    PCMSettings.p_dataBuff = (unsigned char *)pcmdrvDataBuff;
    PCMSettings.dataBuffSize = PCMDRV_BUFFER_SIZE;
    /* buffer length */
    PCMSettings.recSize = PC_MASTER_REC_BUFF_LEN;
    /* recorder time base */
    PCMSettings.timeBase = pcmaster_conf.pc_master_recorder_time_base;

#if (PC_MASTER_APPCMD_BUFF_LEN != 0)
    /* address of buffer */
    PCMSettings.p_appCmdBuff = PCMasterAppCmdBuff;
#endif

    PCMSettings.p_scope = (unsigned char *)&pcmdrvScope;
    /* buffer length */
    PCMSettings.appCmdSize = PC_MASTER_APPCMD_BUFF_LEN;
    /* board firmware version major number */
    PCMSettings.globVerMajor = pcmaster_conf.pc_master_glob_version_major;
    /* board firmware version minor number */
    PCMSettings.globVerMinor = pcmaster_conf.pc_master_glob_version_minor;
    /* device identification string */
    strcpy((char *)PCMSettings.idtString, PC_MASTER_IDT_STRING);
    /* SCI communication initialization */
    pcmasterdrvInit(&PCMSettings);
    pc_master_send = send_hook;
}

/* END PC_M1. */

/*
** ###################################################################
**
**     This file was created by UNIS Processor Expert 2.98 [03.79]
**     for the Freescale 56800 series of microcontrollers.
**
** ###################################################################
*/
